#  Copyright (c) 2023. ç§‹åŸè½å¶, Inc. All Rights Reserved
#  @ä½œè€…         : ç§‹åŸè½å¶(QiuChenly)
#  @é‚®ä»¶         : 1925374620@qq.com
#  @æ–‡ä»¶         : é¡¹ç›® [qqmusic] - Tools.py
#  @ä¿®æ”¹æ—¶é—´    : 2023-03-04 08:59:23
#  @ä¸Šæ¬¡ä¿®æ”¹    : 2023/3/4 ä¸‹åˆ8:59
import base64
import os
import threading

import requests

from web.API.qq import QQApi


def subString(text: str, left: str, right: str):
    """
    å–æ–‡æœ¬ä¸­é—´
    Args:
        text: å®Œæ•´æ–‡æœ¬
        left: å·¦è¾¹æ–‡æœ¬
        right: å³è¾¹æ–‡æœ¬

    Returns:
        è¿”å›ä¸­é—´çš„æ–‡æœ¬

    """
    leftInx = text.find(left)
    leftInx += len(left)
    rightInx = text.find(right, leftInx)
    txt = text[leftInx:rightInx]
    return txt


threadLock = threading.Lock()  # å¤šçº¿ç¨‹é” é˜²æ­¢åŒæ—¶åˆ›å»ºåŒä¸€ä¸ªæ–‡ä»¶å¤¹å†²çª


def downSingle(music, download_home, onlyShowSingerSelfSongs=False, musicAlbumsClassification=True):
    songmid = music['songmid']
    file = QQApi.getQQMusicFileName(music['prefix'], music['mid'], music['extra'])
    musicFileInfo = f"{music['singer']} - {music['title']} [{music['notice']}] {round(int(music['size']) / 1024 / 1024, 2)}MB - {file}"
    musicid = music['musicid']
    # link = getQQMusicDownloadLinkByMacApp(file, songmid)
    # link = getQQMusicDownloadLinkV1(file, songmid)  # æ—©æœŸæ–¹æ³• å¯é£Ÿç”¨
    # vkey = link['purl']
    # link = f'http://ws.stream.qqmusic.qq.com/{vkey}&fromtag=140'
    # if vkey == '':
    #     print(f"æ‰¾ä¸åˆ°èµ„æºæ–‡ä»¶! è§£ææ­Œæ›²ä¸‹è½½åœ°å€å¤±è´¥ï¼{musicFileInfo}")
    #     return False

    # è‡ªåŠ¨åŒ¹é…æ­Œæ›²ç±»å‹
    sourceSelect = "hr" if music['prefix'] == "RS01" else "sq" if music['prefix'] == "F000" else \
        "hq" if music['prefix'] == "M800" else "mp3"

    link = QQApi.getQQMusicDownloadLinkByTrdServer(songmid, sourceSelect)

    # æµ‹è¯•æ­Œè¯ä¸‹è½½ä¿å­˜æ¥å£ä»£ç 
    # lyric = getQQMusicMediaLyric(songmid) # æ—©æœŸæ–¹æ³• å·²å¼ƒç”¨
    # lyric = getQQMusicLyricByMacApp(musicid)
    # lyric = getQQMusicLyricByWeb(musicid)
    # lyrics = base64.b64decode(lyric['lyric'])
    # with open("lyric.txt", 'wb') as code:
    #     code.write(lyrics)
    #     code.flush()
    # æµ‹è¯•æ­Œè¯ä¸‹è½½ä»£ç ç»“æŸ

    if link.find('stream.qqmusic.qq.com') == -1:
        print(f"æ— æ³•åŠ è½½èµ„æºæ–‡ä»¶ï¼è§£ææ­Œæ›²ä¸‹è½½åœ°å€å¤±è´¥ï¼{musicFileInfo}")
        return False

    # prepare
    localFile = f"{music['singer']} - {music['title']}.{music['extra']}".replace(
        "/", "\\")
    localLrcFile = f"{music['singer']} - {music['title']}.lrc".replace(
        "/", "\\")
    mShower = localFile
    my_path = download_home + music['singer'] + '/'

    if not onlyShowSingerSelfSongs:
        if not os.path.exists(my_path):
            os.mkdir(f"{my_path}")

    threadLock.acquire()  # å¤šçº¿ç¨‹ä¸Šé”è§£å†³åŒæ—¶åˆ›å»ºä¸€ä¸ªmkdirçš„é”™è¯¯
    my_path = f"{my_path}{music['album'] if musicAlbumsClassification else ''}"

    try:
        if not os.path.exists(my_path):
            os.mkdir(f"{my_path}")
    except:
        pass
    threadLock.release()
    localFile = os.path.join(my_path, f"{localFile}")
    localLrcFile = os.path.join(my_path, f"{localLrcFile}")

    # ä¸‹è½½æ­Œè¯
    if not os.path.exists(localLrcFile):
        print(f"æœ¬åœ°æ­Œè¯æ–‡ä»¶ä¸å­˜åœ¨,å‡†å¤‡è‡ªåŠ¨ä¸‹è½½: [{localLrcFile}].")
        # lyric = getQQMusicMediaLyric(songmid)  # lyric trans
        lyric = QQApi.getQQMusicLyricByMacApp(musicid)
        if lyric['lyric'] != '':
            # "retcode": 0,
            # "code": 0,
            # "subcode": 0,
            # {'retcode': -1901, 'code': -1901, 'subcode': -1901}
            # å¤–è¯­æ­Œæ›²æœ‰ç¿»è¯‘ ä½†æ˜¯ğŸ‘´ä¸éœ€è¦ï¼
            lyric = base64.b64decode(lyric['lyric'])
            try:
                with open(localLrcFile, 'wb+') as code:
                    code.write(lyric)
                    code.flush()
            except:
                print("æ­Œè¯è·å–å‡ºé”™äº†ï¼")
        else:
            print(f"æ­Œè¯è·å–å¤±è´¥!æœåŠ¡å™¨ä¸Šæœç´¢ä¸åˆ°æ­¤é¦– [{music['singer']} - {music['title']}] æ­Œæ›²æ­Œè¯!")

    # ä¸‹è½½æ­Œæ›²
    if os.path.exists(localFile):
        if os.path.getsize(localFile) == int(music['size']):
            print(f"æœ¬åœ°å·²ä¸‹è½½,è·³è¿‡ä¸‹è½½ [{music['album']} / {mShower}].")
            return True
        else:
            print(
                f"æœ¬åœ°æ–‡ä»¶å°ºå¯¸ä¸ç¬¦: {os.path.getsize(localFile)}/{int(music['size'])},å¼€å§‹è¦†ç›–ä¸‹è½½ [{mShower}].")
    print(f'æ­£åœ¨ä¸‹è½½ | {music["album"]} / {musicFileInfo}')
    f = requests.get(link)
    with open(localFile, 'wb') as code:
        code.write(f.content)
        code.flush()

    return True
